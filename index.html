<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>So Clover - Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #0c1222;
            --panel: #161e35;
            --board: #1f2a4a;
            --accent: #6bd390;
            --accent2: #7abcf7;
            --tile: #23335f;
            --text: #e7eefc;
            --muted: #a6b4d9;
            --danger: #ff6b6b;
            --locked: #3a965a;
            --ok: #51cf66;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden;
        }

        header {
            padding: 12px 16px;
            border-bottom: 1px solid #2b3b6e;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            position: sticky;
            top: 0;
            background: var(--bg);
            z-index: 100;
        }

        header h1 {
            font-size: 1.15rem;
            margin: 0;
            flex-shrink: 0;
        }

        header .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: auto;
        }

        button {
            background: var(--accent);
            color: #062410;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        button.secondary {
            background: var(--accent2);
            color: #091d35;
        }

        button.warn {
            background: var(--danger);
            color: white;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        button:active:not(:disabled) {
            transform: scale(0.98);
        }

        /* Lobby UI */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 16px;
        }

        .modal {
            background: var(--panel);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            margin: 0 0 16px 0;
            font-size: 1.5rem;
        }

        .modal input {
            width: 100%;
            background: var(--bg);
            color: var(--text);
            border: 1px solid #37477c;
            border-radius: 8px;
            padding: 12px;
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .modal input:focus {
            outline: none;
            border-color: var(--accent2);
        }

        .modal .button-group {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .modal .button-group button {
            flex: 1;
        }

        .code-display {
            background: var(--bg);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            margin: 16px 0;
        }

        .code-display .code {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            color: var(--accent);
            font-family: ui-monospace, monospace;
        }

        .code-display .label {
            font-size: 0.9rem;
            color: var(--muted);
            margin-top: 8px;
        }

        .player-list {
            background: var(--bg);
            border: 1px solid #37477c;
            border-radius: 8px;
            padding: 12px;
            margin: 16px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 4px;
            background: var(--panel);
            border-radius: 6px;
        }

        .player-item.ready {
            border-left: 3px solid var(--ok);
        }

        .player-item.active {
            border-left: 3px solid var(--accent);
        }

        .player-item .name {
            flex: 1;
        }

        .player-item .status {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .player-item .status.ready {
            color: var(--ok);
        }

        /* Mobile-first layout */
        main {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
            max-width: 100%;
        }

        /* Compact info panel */
        .panel {
            background: var(--panel);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel h2 {
            margin: 0;
            font-size: 1rem;
            color: var(--muted);
        }

        .log {
            font-family: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
            color: #b9c6ec;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        /* Stage container */
        .stage {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            width: 100%;
        }

        /* Board - responsive sizing */
        .board {
            position: relative;
            width: min(95vw, 600px);
            aspect-ratio: 1;
            background: radial-gradient(circle at 50% 50%, #24335f 0%, var(--board) 60%);
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            overflow: visible;
        }

        /* 2√ó2 Slots - proportional sizing */
        .slot {
            position: absolute;
            width: 34%;
            aspect-ratio: 1;
            border-radius: 12px;
            border: 2px dashed #5a6bbc;
            background: #121a39;
            display: grid;
            place-items: center;
            overflow: visible;
        }

        .slot.tl {
            left: 14.5%;
            top: 14.5%;
        }

        .slot.tr {
            right: 14.5%;
            top: 14.5%;
        }

        .slot.bl {
            left: 14.5%;
            bottom: 14.5%;
        }

        .slot.br {
            right: 14.5%;
            bottom: 14.5%;
        }

        .slot.highlight {
            border-color: var(--accent2);
            box-shadow: 0 0 0 2px var(--accent2);
        }

        /* Tiles - responsive */
        .tile {
            width: 90%;
            aspect-ratio: 1;
            background: var(--tile);
            border-radius: 12px;
            border: 2px solid #3a4c8a;
            position: relative;
            user-select: none;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
            z-index: 5;
            touch-action: none;
        }

        .tile .center-mark {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16%;
            aspect-ratio: 1;
            border-radius: 4px;
            background: #0f1530;
            border: 2px solid #394a86;
        }

        /* Edge labels */
        .edge {
            position: absolute;
            background: #0c1230;
            border: 1px solid #4156a3;
            border-radius: 4px;
            color: var(--text);
            font-size: clamp(0.7rem, 2.2vw, 0.95rem);
            text-align: center;
            box-sizing: border-box;
            padding: 3px 5px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            font-weight: 500;
        }

        .edge.top,
        .edge.bottom {
            width: 70%;
            height: 16%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .edge.top {
            top: 3%;
        }

        .edge.bottom {
            bottom: 3%;
        }

        .edge.left,
        .edge.right {
            width: 16%;
            height: 70%;
            top: 50%;
            transform: translateY(-50%);
            padding: 5px 3px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .edge.left {
            left: 3%;
        }

        .edge.right {
            right: 3%;
        }

        .edge.inner {
            opacity: 0.25;
        }

        .tile.draggable {
            cursor: grab;
        }

        .tile.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .tile.locked {
            border-color: var(--locked);
            box-shadow: 0 0 0 3px var(--locked) inset;
        }

        /* Dock - mobile friendly grid */
        .dock-wrap {
            width: 100%;
            max-width: 600px;
        }

        .dock-title {
            margin: 0 0 12px 0;
            color: var(--muted);
            font-size: 0.95rem;
            text-align: center;
        }

        .dock {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            justify-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--panel);
            border-radius: 12px;
        }

        .dock .tile {
            width: min(140px, 100%);
        }

        /* Clue boxes - mobile optimized */
        .clue-pair {
            position: absolute;
            z-index: 20;
            pointer-events: auto;
            background: rgba(12, 18, 48, 0.98);
            border: 1px solid #4f64ad;
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text);
            font-size: clamp(0.85rem, 3vw, 1rem);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
            text-align: center;
        }

        .clue-pair input {
            width: 100%;
            background: transparent;
            color: var(--text);
            border: none;
            outline: none;
            text-align: center;
            font-size: clamp(0.85rem, 3vw, 1rem);
        }

        .clue-pair .text {
            display: none;
            font-weight: 500;
        }

        .clue-pair .hint {
            display: none;
            font-size: clamp(0.7rem, 2.5vw, 0.85rem);
            color: var(--muted);
            margin-top: 4px;
        }

        /* Top/Bottom clues */
        .clue-pair.top {
            left: 50%;
            top: 1%;
            transform: translateX(-50%);
            width: min(280px, 70%);
        }

        .clue-pair.bottom {
            left: 50%;
            bottom: 1%;
            transform: translateX(-50%);
            width: min(280px, 70%);
        }

        /* Left/Right clues */
        .clue-pair.left,
        .clue-pair.right {
            width: 10%;
            min-width: 40px;
            max-width: 56px;
            height: 50%;
            padding: 6px 4px;
            top: 50%;
            transform: translateY(-50%);
            display: grid;
            place-items: center;
        }

        .clue-pair.left {
            left: 1%;
        }

        .clue-pair.right {
            right: 1%;
        }

        .clue-pair.left input,
        .clue-pair.left .text,
        .clue-pair.left .hint,
        .clue-pair.right input,
        .clue-pair.right .text,
        .clue-pair.right .hint {
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .phase-badge {
            display: inline-block;
            padding: 6px 10px;
            border-radius: 999px;
            background: #2b3b6e;
            color: #cfe1ff;
            font-size: 0.85rem;
        }

        .scorebox {
            background: #0f1530;
            border: 1px solid #37477c;
            border-radius: 10px;
            padding: 10px;
            display: grid;
            gap: 6px;
            font-size: 0.9rem;
        }

        .scorebox .ok {
            color: var(--ok);
        }

        .score-ref {
            background: #0f1530;
            border: 1px solid #37477c;
            border-radius: 10px;
            padding: 8px;
            font-size: 0.75rem;
        }

        .score-ref h3 {
            margin: 0 0 6px 0;
            font-size: 0.8rem;
            color: var(--muted);
            text-align: center;
        }

        .score-ref table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .score-ref th,
        .score-ref td {
            padding: 3px 4px;
            text-align: left;
            border-bottom: 1px solid #2b3b6e;
            color: var(--text);
        }

        .score-ref th {
            font-weight: 600;
            color: var(--muted);
        }

        .score-ref tr.sep td {
            border: none;
            height: 4px;
        }

        .score-ref-toggle {
            width: 100%;
            background: #121a39;
            color: var(--text);
            border: 1px solid #37477c;
            border-radius: 8px;
            padding: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            touch-action: manipulation;
        }

        .score-ref-toggle:hover {
            border-color: var(--accent2);
        }

        .score-ref-body {
            margin-top: 6px;
        }

        .footer-note {
            color: var(--muted);
            font-size: 0.8rem;
            margin: 0;
            line-height: 1.4;
        }

        .lobby-info {
            background: var(--bg);
            border: 1px solid #37477c;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.85rem;
        }

        .lobby-info .room-code {
            font-family: ui-monospace, monospace;
            color: var(--accent);
            font-weight: 600;
        }

        /* Tablet landscape and up */
        @media (min-width: 768px) {
            main {
                display: grid;
                grid-template-columns: minmax(280px, 320px) 1fr;
                gap: 16px;
                padding: 16px;
                align-items: start;
            }

            .stage {
                flex-direction: row;
                justify-content: center;
                align-items: start;
            }

            .board {
                width: min(600px, 60vw);
            }

            .dock-wrap {
                max-width: 300px;
            }

            .dock {
                grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            }

            header h1 {
                font-size: 1.25rem;
            }

            .edge {
                font-size: clamp(0.75rem, 1.5vw, 0.95rem);
            }
        }

        /* Desktop */
        @media (min-width: 1200px) {
            .board {
                width: 760px;
            }

            .dock-wrap {
                max-width: 400px;
            }

            .dock .tile {
                width: 160px;
            }

            .edge {
                font-size: 1.05rem;
                border-radius: 6px;
                padding: 4px 6px;
            }

            .edge.left,
            .edge.right {
                padding: 6px 4px;
            }
        }

        /* Touch improvements */
        @media (hover: none) and (pointer: coarse) {
            button {
                min-height: 44px;
                min-width: 44px;
            }

            .tile {
                cursor: pointer;
            }
        }
    </style>
</head>

<body>

    <header>
        <h1>üçÄ So Clover</h1>
        <div class="controls">
            <button id="lobbyBtn">Join/Create Lobby</button>
            <button id="readyBtn" style="display:none;" disabled>Ready</button>
            <button id="doneBtn" disabled>Done</button>
            <button id="scoreBtn" disabled>Score</button>
        </div>
    </header>

    <!-- Lobby Modal -->
    <div id="lobbyModal" class="modal-overlay" style="display:none;">
        <div class="modal">
            <div id="lobbyStart">
                <h2>Multiplayer Lobby</h2>
                <div class="button-group">
                    <button onclick="createLobby()">Create Lobby</button>
                    <button onclick="showJoinForm()">Join Lobby</button>
                </div>
            </div>

            <div id="lobbyCreate" style="display:none;">
                <h2>Create Lobby</h2>
                <label style="color:var(--muted); font-size:0.9rem; display:block; margin-bottom:8px;">Your Name</label>
                <input type="text" id="hostName" placeholder="Enter your name" maxlength="20">
                <div id="lobbyCodeDisplay" style="display:none;">
                    <div class="code-display">
                        <div class="code" id="roomCode"></div>
                        <div class="label">Share this code with friends</div>
                    </div>
                    <div class="player-list" id="playerList"></div>
                    <button onclick="startGame()" id="startGameBtn" disabled>Start Game (min 2 players)</button>
                </div>
                <div class="button-group" id="createLobbyButtons">
                    <button onclick="showLobbyStart()">Back</button>
                    <button onclick="generateLobby()">Generate Code</button>
                </div>
            </div>

            <div id="lobbyJoin" style="display:none;">
                <h2>Join Lobby</h2>
                <label style="color:var(--muted); font-size:0.9rem; display:block; margin-bottom:8px;">Your Name</label>
                <input type="text" id="joinName" placeholder="Enter your name" maxlength="20">
                <label
                    style="color:var(--muted); font-size:0.9rem; display:block; margin-bottom:8px; margin-top:12px;">Lobby
                    Code</label>
                <input type="text" id="joinCode" placeholder="Enter lobby code" maxlength="10">
                <div class="button-group">
                    <button onclick="showLobbyStart()">Back</button>
                    <button onclick="joinLobby()">Join</button>
                </div>
            </div>
        </div>
    </div>

    <main>
        <!-- Compact help/info panel -->
        <section class="panel">
            <span id="phaseBadge" class="phase-badge">Idle</span>
            <div class="log" id="log"></div>

            <div id="lobbyInfoPanel" style="display:none;" class="lobby-info">
                <div>Room: <span class="room-code" id="displayRoomCode"></span></div>
                <div>Players: <span id="displayPlayerCount">0</span></div>
                <div>Current turn: <span id="displayCurrentPlayer">‚Äî</span></div>
            </div>

            <div class="scorebox">
                <div>Attempt: <span id="attemptLabel">‚Äî</span></div>
                <div>Round score: <span id="roundScore">0</span></div>
                <div id="scoreHint" class="muted"></div>
            </div>

            <p class="footer-note">
                <strong>Clue Phase:</strong> Enter 4 clues for outer edge word pairs.<br>
                <strong>Resolution:</strong> Drag tiles to slots, tap to rotate, then score.
            </p>

            <div class="score-ref">
                <button class="score-ref-toggle" id="scoreRefToggle" aria-expanded="false">
                    Scoring Reference ‚ñæ
                </button>

                <div class="score-ref-body" id="scoreRefBody" hidden>
                    <table>
                        <thead>
                            <tr>
                                <th>Players</th>
                                <th>Score</th>
                                <th>Result</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>3</td>
                                <td>0‚Äì6</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>7‚Äì10</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>11‚Äì14</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>15‚Äì17</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>18</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>
                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>0‚Äì8</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>9‚Äì14</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>15‚Äì19</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>20‚Äì23</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>24</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>
                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>0‚Äì10</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>11‚Äì18</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>19‚Äì24</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>25‚Äì29</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>30</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>
                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>0‚Äì12</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>13‚Äì22</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>23‚Äì29</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>30‚Äì35</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>36</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Stage: board + dock -->
        <section class="stage" id="stage">
            <!-- Board -->
            <div class="board" id="board">
                <!-- 2√ó2 slots -->
                <div class="slot tl" data-slot="tl"></div>
                <div class="slot tr" data-slot="tr"></div>
                <div class="slot bl" data-slot="bl"></div>
                <div class="slot br" data-slot="br"></div>

                <!-- Four outside-edge clues -->
                <div class="clue-pair top" id="clueTop">
                    <input type="text" maxlength="40" placeholder="Top clue">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair right" id="clueRight">
                    <input type="text" maxlength="40" placeholder="Right">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair bottom" id="clueBottom">
                    <input type="text" maxlength="40" placeholder="Bottom clue">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair left" id="clueLeft">
                    <input type="text" maxlength="40" placeholder="Left">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
            </div>

            <!-- Dock -->
            <div class="dock-wrap">
                <h2 class="dock-title">Tile Dock</h2>
                <div id="tray" class="dock"></div>
            </div>
        </section>
    </main>

    <script>
        /* ---------------------------
        Utility
        ----------------------------*/
        function shuffle(arr, randFn = Math.random) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(randFn() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        /* ---------------------------
        Word bank (fixed)
        ----------------------------*/

        const WORDS = [
            "mountain", "valley", "canyon", "plateau", "desert", "dune", "oasis", "forest", "jungle", "meadow", "prairie", "savanna", "tundra", "glacier", "volcano", "island", "archipelago", "peninsula", "coastline", "shore", "beach", "cliff", "cave", "cavern", "waterfall", "river", "stream", "creek", "brook", "lake", "lagoon", "bay", "fjord", "reef", "marsh", "swamp", "bog", "delta", "estuary", "hillside", "summit",

            "dog", "cat", "horse", "cow", "pig", "goat", "sheep", "llama", "alpaca", "deer", "moose", "bison", "camel", "donkey", "zebra", "elephant", "rhino", "hippo", "lion", "tiger", "cheetah", "leopard", "panther", "wolf", "fox", "bear", "koala", "kangaroo", "otter", "beaver", "raccoon", "skunk", "hedgehog", "rabbit", "mouse", "rat", "squirrel", "chipmunk", "bat", "monkey",

            "oak", "maple", "pine", "birch", "cedar", "spruce", "willow", "aspen", "poplar", "sycamore", "palm", "bamboo", "cactus", "aloe", "fern", "moss", "lichen", "ivy", "vine", "tulip", "rose", "daisy", "lily", "orchid", "sunflower", "violet", "peony", "magnolia", "camellia", "lavender", "mint", "basil", "thyme", "rosemary", "sage", "oregano", "nettle", "clover", "acorn", "seed",

            "bread", "butter", "cheese", "milk", "yogurt", "cream", "egg", "bacon", "sausage", "ham", "salad", "soup", "stew", "sandwich", "pizza", "pasta", "noodle", "rice", "curry", "taco", "burrito", "sushi", "dumpling", "pancake", "waffle", "cereal", "granola", "apple", "banana", "orange", "grape", "peach", "pear", "cherry", "lemon", "lime", "blueberry", "strawberry", "chocolate", "cookie",

            "plate", "bowl", "cup", "mug", "glass", "fork", "spoon", "knife", "spatula", "whisk", "ladle", "tongs", "pan", "pot", "kettle", "oven", "stove", "toaster", "blender", "microwave", "fridge", "freezer", "counter", "sink", "faucet", "sponge", "towel", "napkin", "chair", "table", "sofa", "cushion", "pillow", "blanket", "lamp", "candle", "shelf", "drawer", "broom", "bucket",

            "shirt", "t-shirt", "blouse", "sweater", "jacket", "coat", "hoodie", "vest", "dress", "skirt", "pants", "jeans", "shorts", "belt", "scarf", "tie", "bowtie", "hat", "cap", "beanie", "gloves", "mitten", "sock", "shoe", "boot", "sandal", "sneaker", "heel", "laces", "zipper", "button", "collar", "pocket", "sleeve", "fabric", "cotton", "linen", "silk", "denim", "wool",

            "hammer", "nail", "screw", "bolt", "nut", "wrench", "pliers", "drill", "saw", "chisel", "level", "tape", "measure", "sandpaper", "file", "clamp", "vise", "ladder", "toolbox", "glue", "epoxy", "paint", "brush", "roller", "shovel", "rake", "hoe", "axe", "pickaxe", "wheelbarrow", "pipe", "valve", "gasket", "hinge", "socket", "outlet", "wire", "cable", "fuse", "battery",

            "soccer", "football", "basketball", "baseball", "hockey", "tennis", "golf", "volleyball", "rugby", "cricket", "bocce", "badminton", "lacrosse", "fencing", "boxing", "wrestling", "skating", "skiing", "snowboarding", "surfing", "cycling", "running", "jogging", "marathon", "sprint", "relay", "chess", "checkers", "dominoes", "cards", "dice", "puzzle", "riddle", "trivia", "bingo", "karaoke", "foosball", "pinball", "joystick",

            "music", "melody", "rhythm", "harmony", "chord", "scale", "note", "pitch", "tempo", "beat", "song", "lyric", "chorus", "verse", "concert", "recital", "orchestra", "symphony", "band", "choir", "guitar", "piano", "violin", "cello", "trumpet", "trombone", "flute", "clarinet", "saxophone", "drum", "cymbal", "microphone", "speaker", "canvas", "paint", "easel", "palette", "sketch", "sculpture",

            "computer", "laptop", "tablet", "smartphone", "camera", "webcam", "keyboard", "mouse", "monitor", "printer", "router", "modem", "server", "database", "firewall", "cable", "charger", "adapter", "port", "socket", "sensor", "antenna", "satellite", "drone", "console", "gamepad", "controller", "smartwatch", "earbuds", "stylus", "touchscreen", "browser", "website", "app", "file", "folder", "cache", "pixel", "shader", "cursor",

            "car", "truck", "bus", "van", "taxi", "train", "subway", "tram", "trolley", "bicycle", "scooter", "motorcycle", "moped", "skateboard", "rollerblade", "ferry", "boat", "ship", "yacht", "canoe", "kayak", "raft", "sailboat", "barge", "airplane", "jet", "glider", "helicopter", "rocket", "spaceship", "shuttle", "carriage", "wagon", "sled", "sleigh", "snowmobile", "cablecar", "gondola", "elevator",

            "house", "cottage", "cabin", "apartment", "condo", "mansion", "castle", "fortress", "palace", "temple", "museum", "library", "school", "classroom", "office", "studio", "workshop", "garage", "attic", "basement", "hallway", "foyer", "lobby", "kitchen", "pantry", "dining", "living", "bedroom", "bathroom", "closet", "balcony", "terrace", "porch", "patio", "garden", "courtyard", "barn", "shed", "stable", "theater",

            "baker", "chef", "farmer", "gardener", "teacher", "student", "professor", "librarian", "writer", "poet", "artist", "painter", "sculptor", "musician", "singer", "actor", "director", "engineer", "mechanic", "carpenter", "electrician", "plumber", "mason", "tailor", "designer", "doctor", "nurse", "surgeon", "dentist", "therapist", "pilot", "driver", "sailor", "soldier", "guard", "ranger", "cashier", "barista", "waiter",

            "run", "walk", "jump", "hop", "skip", "crawl", "climb", "swim", "dive", "fly", "drive", "ride", "throw", "catch", "kick", "hit", "push", "pull", "lift", "drop", "turn", "spin", "slide", "roll", "hide", "seek", "search", "find", "build", "break", "cut", "paste", "open", "close", "lock", "unlock", "draw", "write", "read", "speak",

            "bright", "dark", "light", "heavy", "soft", "hard", "rough", "smooth", "warm", "cool", "hot", "cold", "fast", "slow", "quick", "quiet", "loud", "clean", "dirty", "fresh", "stale", "salty", "sweet", "bitter", "sour", "spicy", "bland", "sharp", "dull", "small", "big", "tiny", "huge", "narrow", "wide", "short", "tall", "early", "late",

            "idea", "dream", "thought", "memory", "plan", "goal", "hope", "fear", "love", "hate", "joy", "sorrow", "humor", "pride", "guilt", "luck", "fate", "chance", "risk", "rule", "law", "myth", "story", "rumor", "truth", "lie", "secret", "clue", "hint", "sign", "symbol", "pattern", "order", "chaos", "balance", "harmony", "conflict", "peace", "justice",

            "sun", "sunlight", "sunshine", "moon", "star", "sky", "cloud", "fog", "mist", "haze", "rain", "drizzle", "downpour", "storm", "thunder", "lightning", "rainbow", "wind", "breeze", "gust", "gale", "hurricane", "tornado", "blizzard", "snow", "sleet", "hail", "frost", "dew", "icicle", "eclipse", "dusk", "dawn", "sunrise", "sunset", "twilight", "forecast", "climate",

            "ocean", "sea", "wave", "surf", "tide", "current", "ripple", "whirlpool", "foam", "spray", "splash", "bubble", "droplet", "puddle", "pond", "pool", "aquarium", "coral", "kelp", "seaweed", "shoal", "shore", "harbor", "port", "dock", "pier", "anchor", "buoy", "mast", "sail", "hull", "keel", "rudder", "compass", "map", "lantern", "lighthouse", "lifeboat",

            "dragon", "unicorn", "phoenix", "griffin", "mermaid", "centaur", "minotaur", "sphinx", "gargoyle", "troll", "goblin", "elf", "dwarf", "giant", "ogre", "fairy", "sprite", "wizard", "witch", "warlock", "mage", "knight", "paladin", "bard", "druid", "alchemist", "sorcerer", "spell", "potion", "charm", "rune", "relic", "artifact", "crystal", "portal", "quest", "legend", "myth", "prophecy", "citadel",

            "space", "galaxy", "nebula", "star", "planet", "moon", "comet", "asteroid", "meteor", "satellite", "orbit", "apogee", "rocket", "shuttle", "spaceship", "telescope", "observatory", "astronaut", "cosmonaut", "gravity", "magnetism", "energy", "atom", "molecule", "proton", "neutron", "electron", "nucleus", "cell", "tissue", "organ", "DNA", "gene", "enzyme", "quartz", "laboratory", "experiment", "theory", "formula", "spectrum",

            "red", "orange", "yellow", "green", "blue", "indigo", "violet", "pink", "magenta", "cyan", "teal", "turquoise", "maroon", "crimson", "scarlet", "amber", "gold", "silver", "bronze", "black", "white", "gray", "brown", "beige", "circle", "square", "triangle", "rectangle", "rhombus", "diamond", "oval", "ellipse", "star", "heart", "pentagon", "hexagon", "octagon", "cube", "sphere", "pyramid",

            "second", "minute", "hour", "day", "week", "month", "year", "decade", "century", "millennium", "morning", "noon", "afternoon", "evening", "night", "weekend", "weekday", "holiday", "calendar", "schedule", "alarm", "clock", "timer", "stopwatch", "deadline", "birthday", "anniversary", "season", "spring", "summer", "autumn", "winter", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",

            "eagle", "hawk", "falcon", "owl", "parrot", "canary", "sparrow", "robin", "bluebird", "crow", "raven", "pigeon", "dove", "peacock", "swan", "goose", "duck", "turkey", "flamingo", "heron", "stork", "pelican", "hummingbird", "woodpecker", "butterfly", "moth", "bee", "wasp", "hornet", "ant", "termite", "beetle", "ladybug", "dragonfly", "damselfly", "grasshopper", "cricket", "firefly", "caterpillar", "spider",

            "malarkey", "nincompoop", "gizmo", "widget", "hootenanny", "zigzag", "tomfoolery", "wibble", "bananaphone", "snickerdoodle",

            "key", "lock", "door", "window", "wall", "floor", "ceiling", "roof", "brick", "stone", "tile", "paint", "picture", "photo", "frame", "mirror", "clock", "watch", "calendar", "book", "notebook", "paper", "pencil", "pen", "marker", "crayon", "ruler", "glue", "tape", "key", "lock", "door", "window", "wall", "floor", "ceiling", "roof", "brick", "stone", "tile", "paint", "picture", "photo", "frame", "mirror", "clock", "watch", "calendar", "book", "notebook", "paper", "pencil", "pen", "marker", "crayon", "ruler", "glue", "tape", "backpack", "bag", "wallet", "purse", "coin", "cash", "ticket", "receipt", "card", "stamp", "sticker"];

        /* ---------------------------
        Multiplayer State
        ----------------------------*/
        let peer = null;
        let hostConnection = null; // For clients
        let clientConnections = {}; // For host: peerId -> connection
        let myPeerId = null;
        let myName = "";
        let isHost = false;
        let roomCode = "";
        let playerOrder = []; // [{id, name, ready}]
        let currentPlayerIndex = 0;
        let myReadyState = false;

        /* ---------------------------
        State
        ----------------------------*/
        const state = {
            phase: "idle",
            tiles: [],
            solution: { tl: null, tr: null, bl: null, br: null },
            placed: { tl: null, tr: null, bl: null, br: null },
            attempt: 0,
            roundScore: 0,
            clues: { top: "", right: "", bottom: "", left: "" }
        };

        function log(msg) { document.getElementById("log").textContent = msg; }
        function setPhase(p) {
            state.phase = p;
            document.getElementById("phaseBadge").textContent = p[0].toUpperCase() + p.slice(1);
        }
        function setAttempt(n) {
            state.attempt = n;
            document.getElementById("attemptLabel").textContent = n === 0 ? "‚Äî" : (n === 1 ? "First attempt" : "Second attempt");
        }

        /* ---------------------------
        Tiles
        ----------------------------*/
        let nextTileId = 1;
        function makeTile(words) { return { id: "T" + (nextTileId++), words: words.slice(0, 4) }; }
        function rotWords(words, r) {
            const w = words.slice(); r = r % 4;
            return [
                [w[0], w[1], w[2], w[3]],
                [w[3], w[0], w[1], w[2]],
                [w[2], w[3], w[0], w[1]],
                [w[1], w[2], w[3], w[0]]
            ][r];
        }
        function createTileElement(tile, rotation, { draggable = true, rotatable = true, dimInner = false, slotName = null } = {}) {
            const el = document.createElement("div");
            el.className = "tile" + (draggable ? " draggable" : "");
            el.dataset.id = tile.id;
            el.dataset.rotation = rotation;
            el.draggable = draggable;

            const [topW, rightW, bottomW, leftW] = rotWords(tile.words, rotation);

            const edgeTop = document.createElement("div"); edgeTop.className = "edge top"; edgeTop.textContent = topW;
            const edgeRight = document.createElement("div"); edgeRight.className = "edge right"; edgeRight.textContent = rightW;
            const edgeBottom = document.createElement("div"); edgeBottom.className = "edge bottom"; edgeBottom.textContent = bottomW;
            const edgeLeft = document.createElement("div"); edgeLeft.className = "edge left"; edgeLeft.textContent = leftW;

            if (dimInner && slotName) {
                const innerEdges = {
                    tl: ["right", "bottom"], tr: ["left", "bottom"],
                    bl: ["right", "top"], br: ["left", "top"]
                }[slotName];
                for (const e of innerEdges) {
                    ({ top: edgeTop, right: edgeRight, bottom: edgeBottom, left: edgeLeft }[e]).classList.add("inner");
                }
            }

            const centerMark = document.createElement("div"); centerMark.className = "center-mark";
            el.append(edgeTop, edgeRight, edgeBottom, edgeLeft, centerMark);

            if (rotatable) {
                el.addEventListener("click", () => {
                    if (el.classList.contains("locked")) return;
                    const r = (parseInt(el.dataset.rotation, 10) + 1) % 4;
                    el.dataset.rotation = r;
                    const [t, rn, b, l] = rotWords(tile.words, r);
                    edgeTop.textContent = t; edgeRight.textContent = rn; edgeBottom.textContent = b; edgeLeft.textContent = l;

                    const parentSlotName = el.parentElement?.dataset?.slot;
                    if (parentSlotName) {
                        state.placed[parentSlotName] = { tileId: el.dataset.id, rotation: r };
                        broadcastPlacement();
                    }
                });
            }

            if (draggable) {
                el.addEventListener("dragstart", (e) => {
                    if (el.classList.contains("locked")) { e.preventDefault(); return; }
                    el.classList.add("dragging");
                    e.dataTransfer.setData("text/plain", JSON.stringify({ tileId: tile.id }));
                    const img = document.createElement("img");
                    img.src = "data:image/svg+xml;charset=utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='1' height='1'></svg>");
                    e.dataTransfer.setDragImage(img, 0, 0);
                });
                el.addEventListener("dragend", () => el.classList.remove("dragging"));
            }

            return el;
        }

        /* ---------------------------
        Board & dock
        ----------------------------*/
        const trayEl = document.getElementById("tray");
        const slots = {
            tl: document.querySelector(".slot.tl"),
            tr: document.querySelector(".slot.tr"),
            bl: document.querySelector(".slot.bl"),
            br: document.querySelector(".slot.br")
        };
        function clearBoardAndTray() {
            trayEl.innerHTML = "";
            for (const s of Object.values(slots)) s.innerHTML = "";
            state.placed = { tl: null, tr: null, bl: null, br: null };
        }

        for (const [slotName, slotEl] of Object.entries(slots)) {
            slotEl.addEventListener("dragover", (e) => { e.preventDefault(); slotEl.classList.add("highlight"); });
            slotEl.addEventListener("dragleave", () => slotEl.classList.remove("highlight"));
            slotEl.addEventListener("drop", (e) => {
                e.preventDefault();
                slotEl.classList.remove("highlight");

                const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
                const tileEl = document.querySelector(`.tile[data-id="${data.tileId}"]`);
                if (!tileEl) return;

                const existing = slotEl.querySelector(".tile");
                if (existing && existing.classList.contains("locked")) return;
                if (existing) trayEl.appendChild(existing);
                if (tileEl.classList.contains("locked")) return;

                slotEl.appendChild(tileEl);
                state.placed[slotName] = {
                    tileId: tileEl.dataset.id,
                    rotation: parseInt(tileEl.dataset.rotation, 10)
                };

                broadcastPlacement();
                updateScoreButtonState();
            });
        }

        trayEl.addEventListener("dragover", (e) => { e.preventDefault(); });
        trayEl.addEventListener("drop", (e) => {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
            if (!data.tileId) return;
            const tileEl = document.querySelector(`.tile[data-id="${data.tileId}"]`);
            if (!tileEl || tileEl.classList.contains("locked")) return;

            const parentSlotName = tileEl.parentElement?.dataset?.slot;
            if (parentSlotName) state.placed[parentSlotName] = null;

            trayEl.appendChild(tileEl);
            broadcastPlacement();
            updateScoreButtonState();
        });

        /* ---------------------------
        Clues
        ----------------------------*/
        const clueRefs = {
            top: document.querySelector("#clueTop"),
            right: document.querySelector("#clueRight"),
            bottom: document.querySelector("#clueBottom"),
            left: document.querySelector("#clueLeft")
        };
        function setClueHintsFromSolution() {
            const getTile = id => state.tiles.find(t => t.id === id);
            const wordsFor = (slotName, edgeIdx) => {
                const sol = state.solution[slotName];
                return rotWords(getTile(sol.tileId).words, sol.rotation)[edgeIdx];
            };
            const topPair = wordsFor("tl", 0) + " ‚Ä¢ " + wordsFor("tr", 0);
            const rightPair = wordsFor("tr", 1) + " ‚Ä¢ " + wordsFor("br", 1);
            const bottomPair = wordsFor("bl", 2) + " ‚Ä¢ " + wordsFor("br", 2);
            const leftPair = wordsFor("tl", 3) + " ‚Ä¢ " + wordsFor("bl", 3);

            clueRefs.top.querySelector(".hint").textContent = `Words: ${topPair}`;
            clueRefs.right.querySelector(".hint").textContent = `Words: ${rightPair}`;
            clueRefs.bottom.querySelector(".hint").textContent = `Words: ${bottomPair}`;
            clueRefs.left.querySelector(".hint").textContent = `Words: ${leftPair}`;

            setHintsVisible(false);
        }
        function setHintsVisible(visible) {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const hintEl = clueRefs[dir].querySelector(".hint");
                hintEl.style.display = visible ? "block" : "none";
            }
        }
        function showClueLabels() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir], input = box.querySelector("input"), text = box.querySelector(".text");
                const val = state.clues[dir] || "";
                input.style.display = "none";
                text.style.display = "block";
                text.textContent = val.length ? val : `(${dir} clue)`;
            }
        }
        function showClueInputs() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir];
                box.querySelector("input").style.display = "block";
                box.querySelector(".text").style.display = "none";
            }
        }

        function clearClueBoxes() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir];
                const input = box.querySelector("input");
                const text = box.querySelector(".text");
                const hint = box.querySelector(".hint");
                input.value = "";
                text.textContent = "";
                hint.textContent = "";
                input.style.display = "block";
                text.style.display = "none";
            }
            state.clues = { top: "", right: "", bottom: "", left: "" };
            setHintsVisible(false);
        }

        /* ---------------------------
        Button gating
        ----------------------------*/
        const doneBtn = document.getElementById("doneBtn");
        const scoreBtn = document.getElementById("scoreBtn");
        const readyBtn = document.getElementById("readyBtn");

        function updateDoneButtonState() {
            const topVal = clueRefs.top.querySelector("input").value.trim();
            const rightVal = clueRefs.right.querySelector("input").value.trim();
            const bottomVal = clueRefs.bottom.querySelector("input").value.trim();
            const leftVal = clueRefs.left.querySelector("input").value.trim();
            const allFilled = topVal.length && rightVal.length && bottomVal.length && leftVal.length;
            const isMyTurn = !roomCode || isCurrentPlayer();
            doneBtn.disabled = !(state.phase === "clue" && allFilled && isMyTurn);
        }
        ["top", "right", "bottom", "left"].forEach(dir => {
            clueRefs[dir].querySelector("input").addEventListener("input", () => {
                state.clues[dir] = clueRefs[dir].querySelector("input").value.trim();
                updateDoneButtonState();
            });
        });

        function updateScoreButtonState() {
            if (state.phase !== "guess") { scoreBtn.disabled = true; return; }
            const allSlotsHaveTiles =
                !!slots.tl.querySelector(".tile") &&
                !!slots.tr.querySelector(".tile") &&
                !!slots.bl.querySelector(".tile") &&
                !!slots.br.querySelector(".tile");
            const canScore = !roomCode || isPlayerToLeft();
            scoreBtn.disabled = !(allSlotsHaveTiles && canScore);
        }

        /* ---------------------------
        Round generation
        ----------------------------*/
        function newRound() {
            clearClueBoxes();
            clearBoardAndTray();
            nextTileId = 1;
            state.tiles = [];

            const bank = shuffle(WORDS.slice(), Math.random);

            let idx = 0;
            function take4() {
                const chunk = bank.slice(idx, idx + 4);
                idx += 4;
                return chunk.length === 4 ? chunk : shuffle(WORDS.slice(), Math.random).slice(0, 4);
            }

            const solutionTiles = [];
            for (let i = 0; i < 4; i++) {
                const tile = makeTile(take4());
                state.tiles.push(tile);
                solutionTiles.push(tile);
            }
            const decoy = makeTile(take4());
            state.tiles.push(decoy);

            const slotNames = ["tl", "tr", "bl", "br"];
            const tilesShuffled = shuffle(solutionTiles.slice(), Math.random);
            const rotations = shuffle([0, 1, 2, 3], Math.random);
            state.solution = { tl: null, tr: null, bl: null, br: null };
            for (let i = 0; i < 4; i++) {
                state.solution[slotNames[i]] = { tileId: tilesShuffled[i].id, rotation: rotations[i] };
            }

            for (const slotName of slotNames) {
                const sol = state.solution[slotName];
                const tile = solutionTiles.find(t => t.id === sol.tileId);
                const el = createTileElement(tile, sol.rotation, { draggable: false, rotatable: false, dimInner: true, slotName });
                slots[slotName].appendChild(el);
            }

            setClueHintsFromSolution();
            showClueInputs();
            setHintsVisible(false);

            state.roundScore = 0;
            document.getElementById("roundScore").textContent = "0";
            document.getElementById("scoreHint").textContent =
                "Perfect on first attempt awards 6 points (1 per card + 2 bonus). Otherwise, second attempt scores 1 per correct card.";
            setPhase("clue");
            setAttempt(1);

            updateDoneButtonState();
            scoreBtn.disabled = true;

            const isMyTurn = !roomCode || isCurrentPlayer();
            log(isMyTurn ? "Clue Phase: enter the 4 outside-edge clues. 'Done' enables when all four are filled." : `${getCurrentPlayerName()}'s turn to create clues.`);

            // Broadcast new round to all players
            if (isHost) {
                broadcastToAll({ type: "newRound", state: getGameState() });
            }
        }

        function startGuessPhase() {
            if (state.phase !== "clue") return;

            // Save clues
            state.clues.top = clueRefs.top.querySelector("input").value.trim();
            state.clues.right = clueRefs.right.querySelector("input").value.trim();
            state.clues.bottom = clueRefs.bottom.querySelector("input").value.trim();
            state.clues.left = clueRefs.left.querySelector("input").value.trim();

            showClueLabels();
            setHintsVisible(false);

            document.querySelectorAll(".tile").forEach(el => el.remove());
            trayEl.innerHTML = "";
            const tilesShuffled = shuffle(state.tiles.slice(), Math.random);
            for (const tile of tilesShuffled) {
                const randomRot = Math.floor(Math.random() * 4);
                const el = createTileElement(tile, randomRot, { draggable: true, rotatable: true });
                trayEl.appendChild(el);
            }

            setPhase("guess");
            setAttempt(1);
            doneBtn.disabled = true;
            updateScoreButtonState();
            log("Resolution Phase: Drag tiles to slots. Tap to rotate. Then click Score.");

            // Broadcast phase change
            if (isHost) {
                broadcastToAll({ type: "startGuess", state: getGameState() });
            } else if (hostConnection) {
                hostConnection.send({ type: "startGuess", state: getGameState() });
            }
        }

        /* ---------------------------
        Scoring
        ----------------------------*/
        function scoreGuess() {
            if (state.phase !== "guess") return;
            updateScoreButtonState();
            if (scoreBtn.disabled) return;

            const slotNames = ["tl", "tr", "bl", "br"];
            let lockedCount = 0;

            for (const slotName of slotNames) {
                const sol = state.solution[slotName];
                const slotEl = slots[slotName];
                const tileEl = slotEl.querySelector(".tile");
                if (!tileEl) continue;

                const placedId = tileEl.dataset.id;
                const placedRot = parseInt(tileEl.dataset.rotation, 10);

                const isCorrect = sol.tileId === placedId && sol.rotation === placedRot;

                if (isCorrect) {
                    if (!tileEl.classList.contains("locked")) {
                        tileEl.classList.add("locked");
                        tileEl.draggable = false;
                    }
                    lockedCount++;
                } else {
                    if (!tileEl.classList.contains("locked")) {
                        trayEl.appendChild(tileEl);
                        state.placed[slotName] = null;
                    }
                }
            }

            if (state.attempt === 1) {
                if (lockedCount === 4) {
                    state.roundScore = 6;
                    document.getElementById("roundScore").textContent = state.roundScore;
                    setPhase("complete");
                    scoreBtn.disabled = true;
                    setHintsVisible(true);
                    log("üéâ Perfect! All four cards correct on the first try. +6 points.");

                    // Move to next player
                    if (roomCode) {
                        advanceToNextPlayer();
                    }
                } else {
                    setAttempt(2);
                    document.getElementById("scoreHint").textContent =
                        "Second attempt: place remaining cards. You'll score 1 point per correct card.";
                    log(`Locked ${lockedCount} correct card(s). Incorrect cards returned to the dock. Make your second attempt.`);
                    updateScoreButtonState();
                }
            } else if (state.attempt === 2) {
                const lockedFinal = ["tl", "tr", "bl", "br"].filter(s => slots[s].querySelector(".tile.locked")).length;
                state.roundScore = lockedFinal;
                document.getElementById("roundScore").textContent = state.roundScore;
                setPhase("complete");
                scoreBtn.disabled = true;
                setHintsVisible(true);
                log(`Round complete. You scored ${lockedFinal} point(s) on the second attempt.`);

                // Move to next player
                if (roomCode) {
                    advanceToNextPlayer();
                }
            }

            // Broadcast score
            if (isHost) {
                broadcastToAll({ type: "score", state: getGameState() });
            } else if (hostConnection) {
                hostConnection.send({ type: "score", state: getGameState() });
            }
        }

        /* ---------------------------
        Multiplayer Functions
        ----------------------------*/

        function isCurrentPlayer() {
            if (!roomCode || playerOrder.length === 0) return true;
            const currentPlayer = playerOrder[currentPlayerIndex];
            return currentPlayer && currentPlayer.id === myPeerId;
        }

        function isPlayerToLeft() {
            if (!roomCode || playerOrder.length === 0) return true;
            const leftIndex = (currentPlayerIndex + 1) % playerOrder.length;
            const leftPlayer = playerOrder[leftIndex];
            return leftPlayer && leftPlayer.id === myPeerId;
        }

        function getCurrentPlayerName() {
            if (!roomCode || playerOrder.length === 0) return "";
            const currentPlayer = playerOrder[currentPlayerIndex];
            return currentPlayer ? currentPlayer.name : "";
        }

        function advanceToNextPlayer() {
            currentPlayerIndex = (currentPlayerIndex + 1) % playerOrder.length;
            updateLobbyDisplay();

            // Start new round for next player
            setTimeout(() => {
                newRound();
            }, 2000);
        }

        function getGameState() {
            return {
                phase: state.phase,
                tiles: state.tiles,
                solution: state.solution,
                placed: state.placed,
                attempt: state.attempt,
                roundScore: state.roundScore,
                clues: state.clues,
                currentPlayerIndex: currentPlayerIndex
            };
        }

        function applyGameState(gameState) {
            state.phase = gameState.phase;
            state.tiles = gameState.tiles;
            state.solution = gameState.solution;
            state.placed = gameState.placed;
            state.attempt = gameState.attempt;
            state.roundScore = gameState.roundScore;
            state.clues = gameState.clues;
            currentPlayerIndex = gameState.currentPlayerIndex;

            // Update UI
            setPhase(state.phase);
            setAttempt(state.attempt);
            document.getElementById("roundScore").textContent = state.roundScore;

            // Rebuild board
            renderGameBoard();
            updateLobbyDisplay();
        }

        function renderGameBoard() {
            clearBoardAndTray();

            if (state.phase === "clue") {
                // Show solution tiles
                for (const slotName of ["tl", "tr", "bl", "br"]) {
                    const sol = state.solution[slotName];
                    const tile = state.tiles.find(t => t.id === sol.tileId);
                    if (tile) {
                        const el = createTileElement(tile, sol.rotation, { draggable: false, rotatable: false, dimInner: true, slotName });
                        slots[slotName].appendChild(el);
                    }
                }
                setClueHintsFromSolution();
                showClueInputs();

                // Restore clue values
                for (const dir of ["top", "right", "bottom", "left"]) {
                    clueRefs[dir].querySelector("input").value = state.clues[dir] || "";
                }
            } else if (state.phase === "guess" || state.phase === "complete") {
                showClueLabels();

                // Place tiles in slots or tray
                const placedTileIds = new Set();
                for (const slotName of ["tl", "tr", "bl", "br"]) {
                    const placement = state.placed[slotName];
                    if (placement) {
                        const tile = state.tiles.find(t => t.id === placement.tileId);
                        if (tile) {
                            const el = createTileElement(tile, placement.rotation, { draggable: true, rotatable: true });

                            // Check if should be locked
                            const sol = state.solution[slotName];
                            if (sol.tileId === placement.tileId && sol.rotation === placement.rotation) {
                                el.classList.add("locked");
                                el.draggable = false;
                            }

                            slots[slotName].appendChild(el);
                            placedTileIds.add(placement.tileId);
                        }
                    }
                }

                // Put remaining tiles in tray
                for (const tile of state.tiles) {
                    if (!placedTileIds.has(tile.id)) {
                        const existingEl = document.querySelector(`.tile[data-id="${tile.id}"]`);
                        if (!existingEl) {
                            const randomRot = Math.floor(Math.random() * 4);
                            const el = createTileElement(tile, randomRot, { draggable: true, rotatable: true });
                            trayEl.appendChild(el);
                        }
                    }
                }

                if (state.phase === "complete") {
                    setHintsVisible(true);
                }
            }

            updateDoneButtonState();
            updateScoreButtonState();
        }

        function broadcastPlacement() {
            if (!roomCode) return;

            const msg = {
                type: "placement",
                placed: state.placed
            };

            if (isHost) {
                broadcastToAll(msg);
            } else if (hostConnection) {
                hostConnection.send(msg);
            }
        }

        function broadcastToAll(msg) {
            for (const conn of Object.values(clientConnections)) {
                if (conn.open) {
                    conn.send(msg);
                }
            }
        }

        function handleMessage(data, fromPeerId) {
            if (data.type === "placement") {
                state.placed = data.placed;
                renderGameBoard();
            } else if (data.type === "newRound") {
                applyGameState(data.state);
            } else if (data.type === "startGuess") {
                applyGameState(data.state);
            } else if (data.type === "score") {
                applyGameState(data.state);
            } else if (data.type === "playerJoined" && isHost) {
                // Handle new player joining
                const player = { id: fromPeerId, name: data.name, ready: false };
                if (!playerOrder.find(p => p.id === fromPeerId)) {
                    playerOrder.push(player);
                    updatePlayerList();
                    broadcastPlayerList();
                }
            } else if (data.type === "playerList") {
                playerOrder = data.players;
                currentPlayerIndex = data.currentPlayerIndex;
                updatePlayerList();
                updateLobbyDisplay();
            } else if (data.type === "playerReady") {
                const player = playerOrder.find(p => p.id === fromPeerId);
                if (player) {
                    player.ready = data.ready;
                    updatePlayerList();
                    if (isHost) {
                        broadcastPlayerList();
                        checkStartGame();
                    }
                }
            } else if (data.type === "gameStart") {
                applyGameState(data.state);
                document.getElementById("lobbyModal").style.display = "none";
                document.getElementById("readyBtn").style.display = "none";
            }
        }

        function broadcastPlayerList() {
            broadcastToAll({
                type: "playerList",
                players: playerOrder,
                currentPlayerIndex: currentPlayerIndex
            });
        }

        function checkStartGame() {
            const allReady = playerOrder.length >= 2 && playerOrder.every(p => p.ready);
            document.getElementById("startGameBtn").disabled = !allReady;
        }

        function updatePlayerList() {
            const listEl = document.getElementById("playerList");
            if (!listEl) return;

            listEl.innerHTML = playerOrder.map((p, i) => {
                const isCurrent = i === currentPlayerIndex;
                return `<div class="player-item ${p.ready ? 'ready' : ''} ${isCurrent ? 'active' : ''}">
                    <div class="name">${p.name}${p.id === myPeerId ? ' (You)' : ''}</div>
                    <div class="status ${p.ready ? 'ready' : ''}">${p.ready ? '‚úì Ready' : 'Not ready'}</div>
                </div>`;
            }).join('');
        }

        function updateLobbyDisplay() {
            if (roomCode) {
                document.getElementById("lobbyInfoPanel").style.display = "block";
                document.getElementById("displayRoomCode").textContent = roomCode;
                document.getElementById("displayPlayerCount").textContent = playerOrder.length;
                document.getElementById("displayCurrentPlayer").textContent = getCurrentPlayerName();
            }
        }

        /* ---------------------------
        Lobby UI Functions
        ----------------------------*/

        function showLobbyModal() {
            document.getElementById("lobbyModal").style.display = "flex";
            showLobbyStart();
        }

        function showLobbyStart() {
            document.getElementById("lobbyStart").style.display = "block";
            document.getElementById("lobbyCreate").style.display = "none";
            document.getElementById("lobbyJoin").style.display = "none";
        }

        function createLobby() {
            document.getElementById("lobbyStart").style.display = "none";
            document.getElementById("lobbyCreate").style.display = "block";
        }

        function showJoinForm() {
            document.getElementById("lobbyStart").style.display = "none";
            document.getElementById("lobbyJoin").style.display = "block";
        }

        function generateLobby() {
            const name = document.getElementById("hostName").value.trim();
            if (!name) {
                alert("Please enter your name");
                return;
            }

            myName = name;
            isHost = true;

            // Initialize PeerJS
            peer = new Peer();

            peer.on("open", (id) => {
                myPeerId = id;
                roomCode = id.substring(0, 6).toUpperCase();

                document.getElementById("roomCode").textContent = roomCode;
                document.getElementById("lobbyCodeDisplay").style.display = "block";
                document.getElementById("createLobbyButtons").style.display = "none";

                playerOrder = [{ id: myPeerId, name: myName, ready: false }];
                updatePlayerList();

                log(`Lobby created: ${roomCode}`);
            });

            peer.on("connection", (conn) => {
                clientConnections[conn.peer] = conn;

                conn.on("open", () => {
                    log(`Player connected: ${conn.peer}`);
                });

                conn.on("data", (data) => {
                    handleMessage(data, conn.peer);
                });

                conn.on("close", () => {
                    delete clientConnections[conn.peer];
                    playerOrder = playerOrder.filter(p => p.id !== conn.peer);
                    updatePlayerList();
                    broadcastPlayerList();
                });
            });

            peer.on("error", (err) => {
                console.error("Peer error:", err);
                alert("Error creating lobby: " + err.message);
            });
        }

        function joinLobby() {
            const name = document.getElementById("joinName").value.trim();
            const code = document.getElementById("joinCode").value.trim().toLowerCase();

            if (!name || !code) {
                alert("Please enter your name and lobby code");
                return;
            }

            myName = name;
            isHost = false;

            // Initialize PeerJS
            peer = new Peer();

            peer.on("open", (id) => {
                myPeerId = id;
                roomCode = code.toUpperCase();

                // Find the host peer ID (we only have the first 6 chars)
                // For PeerJS cloud server, we need the full peer ID
                // This is a limitation - in production, you'd use a signaling server

                // For now, try to connect directly if we have the full peer ID
                const hostPeerId = code;
                hostConnection = peer.connect(hostPeerId);

                hostConnection.on("open", () => {
                    log(`Connected to lobby: ${roomCode}`);
                    document.getElementById("lobbyModal").style.display = "none";
                    document.getElementById("readyBtn").style.display = "inline-block";

                    // Send join message
                    hostConnection.send({ type: "playerJoined", name: myName });

                    updateLobbyDisplay();
                });

                hostConnection.on("data", (data) => {
                    handleMessage(data, hostPeerId);
                });

                hostConnection.on("close", () => {
                    log("Disconnected from lobby");
                    alert("Disconnected from lobby");
                });

                hostConnection.on("error", (err) => {
                    console.error("Connection error:", err);
                    alert("Could not connect to lobby. Make sure the code is correct.");
                });
            });

            peer.on("error", (err) => {
                console.error("Peer error:", err);
                alert("Error joining lobby: " + err.message);
            });
        }

        function toggleReady() {
            myReadyState = !myReadyState;

            const player = playerOrder.find(p => p.id === myPeerId);
            if (player) {
                player.ready = myReadyState;
            }

            readyBtn.textContent = myReadyState ? "Not Ready" : "Ready";
            readyBtn.className = myReadyState ? "warn" : "";

            updatePlayerList();

            if (isHost) {
                broadcastPlayerList();
                checkStartGame();
            } else if (hostConnection) {
                hostConnection.send({ type: "playerReady", ready: myReadyState });
            }
        }

        function startGame() {
            if (playerOrder.length < 2) {
                alert("Need at least 2 players to start");
                return;
            }

            if (!playerOrder.every(p => p.ready)) {
                alert("All players must be ready");
                return;
            }

            // Start the game
            currentPlayerIndex = 0;
            newRound();

            document.getElementById("lobbyModal").style.display = "none";
            document.getElementById("readyBtn").style.display = "none";

            // Broadcast game start
            broadcastToAll({
                type: "gameStart",
                state: getGameState()
            });
        }

        /* ---------------------------
        Event handlers
        ----------------------------*/
        document.getElementById("lobbyBtn").addEventListener("click", showLobbyModal);
        document.getElementById("readyBtn").addEventListener("click", toggleReady);
        document.getElementById("doneBtn").addEventListener("click", startGuessPhase);
        document.getElementById("scoreBtn").addEventListener("click", scoreGuess);

        /* ---------------------------
        Scoring reference toggle
        ----------------------------*/
        const scoreRefToggle = document.getElementById("scoreRefToggle");
        const scoreRefBody = document.getElementById("scoreRefBody");

        scoreRefToggle?.addEventListener("click", () => {
            const isOpen = !scoreRefBody.hasAttribute("hidden");
            scoreRefBody.toggleAttribute("hidden", isOpen);
            scoreRefToggle.setAttribute("aria-expanded", String(!isOpen));
            scoreRefToggle.textContent = `Scoring Reference ${isOpen ? "‚ñæ" : "‚ñ¥"}`;
        });

        /* ---------------------------
        Init
        ----------------------------*/
        (function init() {
            setPhase("idle");
            setAttempt(0);
            document.getElementById("roundScore").textContent = "0";
            document.getElementById("scoreHint").textContent = "";
            log("Click 'Join/Create Lobby' to play multiplayer, or start a solo game.");
        })();
    </script>

</body>

</html>