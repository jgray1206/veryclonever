<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>So Clover</title>
    <style>
        :root {
            --bg: #0c1222;
            --panel: #161e35;
            --board: #1f2a4a;
            --accent: #6bd390;
            --accent2: #7abcf7;
            --tile: #23335f;
            --text: #e7eefc;
            --muted: #a6b4d9;
            --danger: #ff6b6b;
            --locked: #3a965a;
            --ok: #51cf66;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        header {
            padding: 16px 24px;
            border-bottom: 1px solid #2b3b6e;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        header h1 {
            font-size: 1.25rem;
            margin: 0;
        }

        header .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-left: auto;
        }

        button {
            background: var(--accent);
            color: #062410;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-weight: 600;
            cursor: pointer;
        }

        button.secondary {
            background: var(--accent2);
            color: #091d35;
        }

        button.warn {
            background: var(--danger);
            color: white;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Layout: compact info panel + stage (board+dock) */
        main {
            display: grid;
            grid-template-columns: fit-content(320px) 1fr;
            /* left shrinks to content up to ~320px */
            gap: 16px;
            padding: 16px;
            align-items: start;
        }

        /* Compact info panel */
        .panel {
            background: var(--panel);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: auto;
            max-width: 320px;
        }

        .panel h2 {
            margin: 0;
            font-size: 1rem;
            color: var(--muted);
        }

        .log {
            font-family: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
            color: #b9c6ec;
            font-size: 0.9rem;
        }

        /* Stage: board + dock side-by-side */
        .stage {
            display: grid;
            grid-template-columns: 760px minmax(240px, 480px);
            /* board fixed, dock flexible */
            gap: 16px;
            align-items: start;
            justify-content: center;
            /* center the stage in the right column */
        }

        /* Board */
        .board {
            position: relative;
            width: 760px;
            height: 760px;
            background: radial-gradient(circle at 50% 50%, #24335f 0%, var(--board) 60%);
            border-radius: 24px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            overflow: visible;
        }

        /* 2√ó2 Slots ‚Äî pulled closer (small ~10px gap between tiles) */
        .slot {
            position: absolute;
            width: 260px;
            height: 260px;
            border-radius: 20px;
            border: 2px dashed #5a6bbc;
            background: #121a39;
            display: grid;
            place-items: center;
            overflow: visible;
        }

        .slot.tl {
            left: 110px;
            top: 110px;
        }

        .slot.tr {
            left: 380px;
            top: 110px;
        }

        .slot.bl {
            left: 110px;
            top: 380px;
        }

        .slot.br {
            left: 380px;
            top: 380px;
        }

        .slot.highlight {
            border-color: var(--accent2);
            box-shadow: 0 0 0 2px var(--accent2);
        }

        /* Tiles ‚Äî full size */
        .tile {
            width: 220px;
            height: 220px;
            background: var(--tile);
            border-radius: 16px;
            border: 2px solid #3a4c8a;
            position: relative;
            user-select: none;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
            z-index: 5;
        }

        .tile .center-mark {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: #0f1530;
            border: 2px solid #394a86;
        }

        /* Edge labels ‚Äî horizontal vs vertical */
        .edge {
            position: absolute;
            background: #0c1230;
            border: 1px solid #4156a3;
            border-radius: 8px;
            color: var(--text);
            font-size: 0.95rem;
            text-align: center;
            box-sizing: border-box;
            padding: 6px 8px;
        }

        .edge.top,
        .edge.bottom {
            width: 80%;
            min-height: 28px;
            left: 50%;
            transform: translateX(-50%);
        }

        .edge.top {
            top: 6px;
        }

        .edge.bottom {
            bottom: 6px;
        }

        .edge.left,
        .edge.right {
            width: 28px;
            height: 80%;
            top: 50%;
            transform: translateY(-50%);
            padding: 6px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .edge.left {
            left: 6px;
        }

        .edge.right {
            right: 6px;
        }

        .edge.inner {
            opacity: 0.25;
        }

        /* inner 8 words dim in clue phase */

        .tile.draggable {
            cursor: grab;
        }

        .tile.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .tile.locked {
            border-color: var(--locked);
            box-shadow: 0 0 0 3px var(--locked) inset;
        }

        /* Dock (to the right) ‚Äî full-size tiles, auto 1‚Äì2 columns depending on width */
        .dock-title {
            margin: 0 0 8px 0;
            color: var(--muted);
            font-size: 1rem;
        }

        .dock {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            /* 1 or 2 cols as width allows */
            justify-items: center;
            gap: 16px;
        }

        /* Clue boxes around the board (outside-edge clues) */
        .clue-pair {
            position: absolute;
            z-index: 20;
            pointer-events: auto;
            background: rgba(12, 18, 48, 0.96);
            border: 1px solid #4f64ad;
            border-radius: 10px;
            padding: 8px 12px;
            color: var(--text);
            font-size: 1rem;
            min-width: 280px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
            text-align: center;
        }

        .clue-pair input {
            width: 100%;
            background: transparent;
            color: var(--text);
            border: none;
            outline: none;
            text-align: center;
            font-size: 1rem;
        }

        .clue-pair .text {
            display: none;
        }

        /* Hide pair words until round complete */
        .clue-pair .hint {
            display: none;
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 4px;
        }

        /* Top/Bottom (horizontal) positions */
        .clue-pair.top {
            left: 50%;
            top: 12px;
            transform: translateX(-50%);
        }

        .clue-pair.bottom {
            left: 50%;
            bottom: 12px;
            transform: translateX(-50%);
        }

        /* LEFT/RIGHT: vertical boxes hugging outer edges */
        .clue-pair.left,
        .clue-pair.right {
            width: 56px;
            height: 300px;
            padding: 8px 6px;
            min-width: unset;
            top: 50%;
            transform: translateY(-50%);
            display: grid;
            place-items: center;
        }

        .clue-pair.left {
            left: 8px;
        }

        .clue-pair.right {
            right: 8px;
        }

        .clue-pair.left input,
        .clue-pair.left .text,
        .clue-pair.left .hint,
        .clue-pair.right input,
        .clue-pair.right .text,
        .clue-pair.right .hint {
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .phase-badge {
            display: inline-block;
            padding: 6px 10px;
            border-radius: 999px;
            background: #2b3b6e;
            color: #cfe1ff;
            font-size: 0.85rem;
        }

        .scorebox {
            background: #0f1530;
            border: 1px solid #37477c;
            border-radius: 10px;
            padding: 10px;
            display: grid;
            gap: 6px;
        }

        .scorebox .ok {
            color: var(--ok);
        }

        .score-ref {
            margin-top: 10px;
            background: #0f1530;
            border: 1px solid #37477c;
            border-radius: 10px;
            padding: 8px;
            font-size: 0.75rem;
        }

        .score-ref h3 {
            margin: 0 0 6px 0;
            font-size: 0.8rem;
            color: var(--muted);
            text-align: center;
        }

        .score-ref table {
            width: 100%;
            border-collapse: collapse;
        }

        .score-ref th,
        .score-ref td {
            padding: 2px 4px;
            text-align: left;
            border-bottom: 1px solid #2b3b6e;
            color: var(--text);
        }

        .score-ref th {
            font-weight: 600;
            color: var(--muted);
        }

        .score-ref tr.sep td {
            border: none;
            height: 6px;
        }

        .score-ref-toggle {
            width: 100%;
            background: #121a39;
            color: var(--text);
            border: 1px solid #37477c;
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .score-ref-toggle:hover {
            border-color: var(--accent2);
        }

        .score-ref-body {
            margin-top: 6px;
        }
    </style>
</head>

<body>

    <header>
        <h1>üåø So Clover</h1>
        <div class="controls">
            <button id="newRoundBtn">New Round</button>
            <button id="doneBtn" disabled>Done (clue giver)</button>
            <button id="scoreBtn" disabled>Score</button>
            <!-- No Reset -->
        </div>
    </header>

    <main>
        <!-- Compact help/info panel (top-left) -->
        <section class="panel">
            <span id="phaseBadge" class="phase-badge">Idle</span>
            <div class="log" id="log"></div>

            <div class="scorebox">
                <div>Attempt: <span id="attemptLabel">‚Äî</span></div>
                <div>Round score: <span id="roundScore">0</span></div>
                <div id="scoreHint" class="muted"></div>
            </div>
            <div>
                <p class="footer-note" style="color:var(--muted); font-size:0.85rem; margin:0;">
                    Clue Phase: enter 4 clues (Top/Right/Bottom/Left) for outer edge pairs.<br />
                    Resolution: drag 4 originals + 1 decoy to TL/TR/BL/BR, rotate by click, then Score.
                </p>
            </div>
            <div class="score-ref">
                <button class="score-ref-toggle" id="scoreRefToggle" aria-expanded="false">
                    Scoring Reference ‚ñæ
                </button>

                <div class="score-ref-body" id="scoreRefBody" hidden>
                    <table>
                        <thead>
                            <tr>
                                <th>Players</th>
                                <th>Score</th>
                                <th>Result</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>3</td>
                                <td>0‚Äì6</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>7‚Äì10</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>11‚Äì14</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>15‚Äì17</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>18</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>

                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>

                            <tr>
                                <td>4</td>
                                <td>0‚Äì8</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>9‚Äì14</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>15‚Äì19</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>20‚Äì23</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>24</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>

                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>

                            <tr>
                                <td>5</td>
                                <td>0‚Äì10</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>11‚Äì18</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>19‚Äì24</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>25‚Äì29</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>30</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>

                            <tr class="sep">
                                <td colspan="3"></td>
                            </tr>

                            <tr>
                                <td>6</td>
                                <td>0‚Äì12</td>
                                <td>üå± Small sprout</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>13‚Äì22</td>
                                <td>üåø Growth</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>23‚Äì29</td>
                                <td>üåº First bud</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>30‚Äì35</td>
                                <td>üå∏ Blossom</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>36</td>
                                <td>üçÄ Four-leaf clover</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <br />
        </section>

        <!-- Stage: board + dock side-by-side -->
        <section class="stage" id="stage">
            <!-- Board -->
            <div class="board" id="board">
                <!-- 2√ó2 slots -->
                <div class="slot tl" data-slot="tl"></div>
                <div class="slot tr" data-slot="tr"></div>
                <div class="slot bl" data-slot="bl"></div>
                <div class="slot br" data-slot="br"></div>

                <!-- Four outside-edge clues -->
                <div class="clue-pair top" id="clueTop">
                    <input type="text" maxlength="40" placeholder="Top clue (TL.top + TR.top)">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair right" id="clueRight">
                    <input type="text" maxlength="40" placeholder="Right clue (TR.right + BR.right)">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair bottom" id="clueBottom">
                    <input type="text" maxlength="40" placeholder="Bottom clue (BL.bottom + BR.bottom)">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
                <div class="clue-pair left" id="clueLeft">
                    <input type="text" maxlength="40" placeholder="Left clue (TL.left + BL.left)">
                    <div class="text"></div>
                    <div class="hint"></div>
                </div>
            </div>

            <!-- Dock (to the right) -->
            <div class="dock-wrap">
                <h2 class="dock-title">Tile Dock (drag from here)</h2>
                <div id="tray" class="dock"></div>
            </div>
        </section>
    </main>

    <script>
        /* ---------------------------
        Utility
        ----------------------------*/
        function shuffle(arr, randFn = Math.random) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(randFn() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        /* ---------------------------
        Word bank (fixed)
        ----------------------------*/

        const WORDS = [
            "mountain", "valley", "canyon", "plateau", "desert", "dune", "oasis", "forest", "jungle", "meadow", "prairie", "savanna", "tundra", "glacier", "volcano", "island", "archipelago", "peninsula", "coastline", "shore", "beach", "cliff", "cave", "cavern", "waterfall", "river", "stream", "creek", "brook", "lake", "lagoon", "bay", "fjord", "reef", "marsh", "swamp", "bog", "delta", "estuary", "hillside", "summit",

            "dog", "cat", "horse", "cow", "pig", "goat", "sheep", "llama", "alpaca", "deer", "moose", "bison", "camel", "donkey", "zebra", "elephant", "rhino", "hippo", "lion", "tiger", "cheetah", "leopard", "panther", "wolf", "fox", "bear", "koala", "kangaroo", "otter", "beaver", "raccoon", "skunk", "hedgehog", "rabbit", "mouse", "rat", "squirrel", "chipmunk", "bat", "monkey",

            "oak", "maple", "pine", "birch", "cedar", "spruce", "willow", "aspen", "poplar", "sycamore", "palm", "bamboo", "cactus", "aloe", "fern", "moss", "lichen", "ivy", "vine", "tulip", "rose", "daisy", "lily", "orchid", "sunflower", "violet", "peony", "magnolia", "camellia", "lavender", "mint", "basil", "thyme", "rosemary", "sage", "oregano", "nettle", "clover", "acorn", "seed",

            "bread", "butter", "cheese", "milk", "yogurt", "cream", "egg", "bacon", "sausage", "ham", "salad", "soup", "stew", "sandwich", "pizza", "pasta", "noodle", "rice", "curry", "taco", "burrito", "sushi", "dumpling", "pancake", "waffle", "cereal", "granola", "apple", "banana", "orange", "grape", "peach", "pear", "cherry", "lemon", "lime", "blueberry", "strawberry", "chocolate", "cookie",

            "plate", "bowl", "cup", "mug", "glass", "fork", "spoon", "knife", "spatula", "whisk", "ladle", "tongs", "pan", "pot", "kettle", "oven", "stove", "toaster", "blender", "microwave", "fridge", "freezer", "counter", "sink", "faucet", "sponge", "towel", "napkin", "chair", "table", "sofa", "cushion", "pillow", "blanket", "lamp", "candle", "shelf", "drawer", "broom", "bucket",

            "shirt", "t-shirt", "blouse", "sweater", "jacket", "coat", "hoodie", "vest", "dress", "skirt", "pants", "jeans", "shorts", "belt", "scarf", "tie", "bowtie", "hat", "cap", "beanie", "gloves", "mitten", "sock", "shoe", "boot", "sandal", "sneaker", "heel", "laces", "zipper", "button", "collar", "pocket", "sleeve", "fabric", "cotton", "linen", "silk", "denim", "wool",

            "hammer", "nail", "screw", "bolt", "nut", "wrench", "pliers", "drill", "saw", "chisel", "level", "tape", "measure", "sandpaper", "file", "clamp", "vise", "ladder", "toolbox", "glue", "epoxy", "paint", "brush", "roller", "shovel", "rake", "hoe", "axe", "pickaxe", "wheelbarrow", "pipe", "valve", "gasket", "hinge", "socket", "outlet", "wire", "cable", "fuse", "battery",

            "soccer", "football", "basketball", "baseball", "hockey", "tennis", "golf", "volleyball", "rugby", "cricket", "bocce", "badminton", "lacrosse", "fencing", "boxing", "wrestling", "skating", "skiing", "snowboarding", "surfing", "cycling", "running", "jogging", "marathon", "sprint", "relay", "chess", "checkers", "dominoes", "cards", "dice", "puzzle", "riddle", "trivia", "bingo", "karaoke", "foosball", "pinball", "joystick",

            "music", "melody", "rhythm", "harmony", "chord", "scale", "note", "pitch", "tempo", "beat", "song", "lyric", "chorus", "verse", "concert", "recital", "orchestra", "symphony", "band", "choir", "guitar", "piano", "violin", "cello", "trumpet", "trombone", "flute", "clarinet", "saxophone", "drum", "cymbal", "microphone", "speaker", "canvas", "paint", "easel", "palette", "sketch", "sculpture",

            "computer", "laptop", "tablet", "smartphone", "camera", "webcam", "keyboard", "mouse", "monitor", "printer", "router", "modem", "server", "database", "firewall", "cable", "charger", "adapter", "port", "socket", "sensor", "antenna", "satellite", "drone", "console", "gamepad", "controller", "smartwatch", "earbuds", "stylus", "touchscreen", "browser", "website", "app", "file", "folder", "cache", "pixel", "shader", "cursor",

            "car", "truck", "bus", "van", "taxi", "train", "subway", "tram", "trolley", "bicycle", "scooter", "motorcycle", "moped", "skateboard", "rollerblade", "ferry", "boat", "ship", "yacht", "canoe", "kayak", "raft", "sailboat", "barge", "airplane", "jet", "glider", "helicopter", "rocket", "spaceship", "shuttle", "carriage", "wagon", "sled", "sleigh", "snowmobile", "cablecar", "gondola", "elevator",

            "house", "cottage", "cabin", "apartment", "condo", "mansion", "castle", "fortress", "palace", "temple", "museum", "library", "school", "classroom", "office", "studio", "workshop", "garage", "attic", "basement", "hallway", "foyer", "lobby", "kitchen", "pantry", "dining", "living", "bedroom", "bathroom", "closet", "balcony", "terrace", "porch", "patio", "garden", "courtyard", "barn", "shed", "stable", "theater",

            "baker", "chef", "farmer", "gardener", "teacher", "student", "professor", "librarian", "writer", "poet", "artist", "painter", "sculptor", "musician", "singer", "actor", "director", "engineer", "mechanic", "carpenter", "electrician", "plumber", "mason", "tailor", "designer", "doctor", "nurse", "surgeon", "dentist", "therapist", "pilot", "driver", "sailor", "soldier", "guard", "ranger", "cashier", "barista", "waiter",

            "run", "walk", "jump", "hop", "skip", "crawl", "climb", "swim", "dive", "fly", "drive", "ride", "throw", "catch", "kick", "hit", "push", "pull", "lift", "drop", "turn", "spin", "slide", "roll", "hide", "seek", "search", "find", "build", "break", "cut", "paste", "open", "close", "lock", "unlock", "draw", "write", "read", "speak",

            "bright", "dark", "light", "heavy", "soft", "hard", "rough", "smooth", "warm", "cool", "hot", "cold", "fast", "slow", "quick", "quiet", "loud", "clean", "dirty", "fresh", "stale", "salty", "sweet", "bitter", "sour", "spicy", "bland", "sharp", "dull", "small", "big", "tiny", "huge", "narrow", "wide", "short", "tall", "early", "late",

            "idea", "dream", "thought", "memory", "plan", "goal", "hope", "fear", "love", "hate", "joy", "sorrow", "humor", "pride", "guilt", "luck", "fate", "chance", "risk", "rule", "law", "myth", "story", "rumor", "truth", "lie", "secret", "clue", "hint", "sign", "symbol", "pattern", "order", "chaos", "balance", "harmony", "conflict", "peace", "justice",

            "sun", "sunlight", "sunshine", "moon", "star", "sky", "cloud", "fog", "mist", "haze", "rain", "drizzle", "downpour", "storm", "thunder", "lightning", "rainbow", "wind", "breeze", "gust", "gale", "hurricane", "tornado", "blizzard", "snow", "sleet", "hail", "frost", "dew", "icicle", "eclipse", "dusk", "dawn", "sunrise", "sunset", "twilight", "forecast", "climate",

            "ocean", "sea", "wave", "surf", "tide", "current", "ripple", "whirlpool", "foam", "spray", "splash", "bubble", "droplet", "puddle", "pond", "pool", "aquarium", "coral", "kelp", "seaweed", "shoal", "shore", "harbor", "port", "dock", "pier", "anchor", "buoy", "mast", "sail", "hull", "keel", "rudder", "compass", "map", "lantern", "lighthouse", "lifeboat",

            "dragon", "unicorn", "phoenix", "griffin", "mermaid", "centaur", "minotaur", "sphinx", "gargoyle", "troll", "goblin", "elf", "dwarf", "giant", "ogre", "fairy", "sprite", "wizard", "witch", "warlock", "mage", "knight", "paladin", "bard", "druid", "alchemist", "sorcerer", "spell", "potion", "charm", "rune", "relic", "artifact", "crystal", "portal", "quest", "legend", "myth", "prophecy", "citadel",

            "space", "galaxy", "nebula", "star", "planet", "moon", "comet", "asteroid", "meteor", "satellite", "orbit", "apogee", "rocket", "shuttle", "spaceship", "telescope", "observatory", "astronaut", "cosmonaut", "gravity", "magnetism", "energy", "atom", "molecule", "proton", "neutron", "electron", "nucleus", "cell", "tissue", "organ", "DNA", "gene", "enzyme", "quartz", "laboratory", "experiment", "theory", "formula", "spectrum",

            "red", "orange", "yellow", "green", "blue", "indigo", "violet", "pink", "magenta", "cyan", "teal", "turquoise", "maroon", "crimson", "scarlet", "amber", "gold", "silver", "bronze", "black", "white", "gray", "brown", "beige", "circle", "square", "triangle", "rectangle", "rhombus", "diamond", "oval", "ellipse", "star", "heart", "pentagon", "hexagon", "octagon", "cube", "sphere", "pyramid",

            "second", "minute", "hour", "day", "week", "month", "year", "decade", "century", "millennium", "morning", "noon", "afternoon", "evening", "night", "weekend", "weekday", "holiday", "calendar", "schedule", "alarm", "clock", "timer", "stopwatch", "deadline", "birthday", "anniversary", "season", "spring", "summer", "autumn", "winter", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",

            "eagle", "hawk", "falcon", "owl", "parrot", "canary", "sparrow", "robin", "bluebird", "crow", "raven", "pigeon", "dove", "peacock", "swan", "goose", "duck", "turkey", "flamingo", "heron", "stork", "pelican", "hummingbird", "woodpecker", "butterfly", "moth", "bee", "wasp", "hornet", "ant", "termite", "beetle", "ladybug", "dragonfly", "damselfly", "grasshopper", "cricket", "firefly", "caterpillar", "spider",

            "malarkey", "nincompoop", "gizmo", "widget", "hootenanny", "zigzag", "tomfoolery", "wibble", "bananaphone", "snickerdoodle",

            "key", "lock", "door", "window", "wall", "floor", "ceiling", "roof", "brick", "stone", "tile", "paint", "picture", "photo", "frame", "mirror", "clock", "watch", "calendar", "book", "notebook", "paper", "pencil", "pen", "marker", "crayon", "ruler", "glue", "tape", "key", "lock", "door", "window", "wall", "floor", "ceiling", "roof", "brick", "stone", "tile", "paint", "picture", "photo", "frame", "mirror", "clock", "watch", "calendar", "book", "notebook", "paper", "pencil", "pen", "marker", "crayon", "ruler", "glue", "tape", "backpack", "bag", "wallet", "purse", "coin", "cash", "ticket", "receipt", "card", "stamp", "sticker"];

        /* ---------------------------
        State
        ----------------------------*/
        const state = {
            phase: "idle", // idle | clue | guess | complete
            tiles: [], // [{id, words:[top,right,bottom,left]}] ‚Äî includes decoy in guess phase
            solution: { tl: null, tr: null, bl: null, br: null }, // { tileId, rotation }
            placed: { tl: null, tr: null, bl: null, br: null }, // { tileId, rotation }
            attempt: 0, // 0 none, 1 first, 2 second
            roundScore: 0
        };

        function log(msg) { document.getElementById("log").textContent = msg; }
        function setPhase(p) {
            state.phase = p;
            document.getElementById("phaseBadge").textContent = p[0].toUpperCase() + p.slice(1);
        }
        function setAttempt(n) {
            state.attempt = n;
            document.getElementById("attemptLabel").textContent = n === 0 ? "‚Äî" : (n === 1 ? "First attempt" : "Second attempt");
        }

        /* ---------------------------
        Tiles
        ----------------------------*/
        let nextTileId = 1;
        function makeTile(words) { return { id: "T" + (nextTileId++), words: words.slice(0, 4) }; }
        function rotWords(words, r) {
            const w = words.slice(); r = r % 4;
            return [
                [w[0], w[1], w[2], w[3]], // 0
                [w[3], w[0], w[1], w[2]], // 1
                [w[2], w[3], w[0], w[1]], // 2
                [w[1], w[2], w[3], w[0]] // 3
            ][r];
        }
        function createTileElement(tile, rotation, { draggable = true, rotatable = true, dimInner = false, slotName = null } = {}) {
            const el = document.createElement("div");
            el.className = "tile" + (draggable ? " draggable" : "");
            el.dataset.id = tile.id;
            el.dataset.rotation = rotation;
            el.draggable = draggable;

            const [topW, rightW, bottomW, leftW] = rotWords(tile.words, rotation);

            const edgeTop = document.createElement("div"); edgeTop.className = "edge top"; edgeTop.textContent = topW;
            const edgeRight = document.createElement("div"); edgeRight.className = "edge right"; edgeRight.textContent = rightW;
            const edgeBottom = document.createElement("div"); edgeBottom.className = "edge bottom"; edgeBottom.textContent = bottomW;
            const edgeLeft = document.createElement("div"); edgeLeft.className = "edge left"; edgeLeft.textContent = leftW;

            if (dimInner && slotName) {
                const innerEdges = {
                    tl: ["right", "bottom"], tr: ["left", "bottom"],
                    bl: ["right", "top"], br: ["left", "top"]
                }[slotName];
                for (const e of innerEdges) {
                    ({ top: edgeTop, right: edgeRight, bottom: edgeBottom, left: edgeLeft }[e]).classList.add("inner");
                }
            }

            const centerMark = document.createElement("div"); centerMark.className = "center-mark";
            el.append(edgeTop, edgeRight, edgeBottom, edgeLeft, centerMark);

            if (rotatable) {
                el.addEventListener("click", () => {
                    if (el.classList.contains("locked")) return;
                    const r = (parseInt(el.dataset.rotation, 10) + 1) % 4;
                    el.dataset.rotation = r;
                    const [t, rn, b, l] = rotWords(tile.words, r);
                    edgeTop.textContent = t; edgeRight.textContent = rn; edgeBottom.textContent = b; edgeLeft.textContent = l;

                    // Keep state.placed in sync if rotated in a slot
                    const parentSlotName = el.parentElement?.dataset?.slot;
                    if (parentSlotName) {
                        state.placed[parentSlotName] = { tileId: el.dataset.id, rotation: r };
                    }
                });
            }

            if (draggable) {
                el.addEventListener("dragstart", (e) => {
                    if (el.classList.contains("locked")) { e.preventDefault(); return; }
                    el.classList.add("dragging");
                    e.dataTransfer.setData("text/plain", JSON.stringify({ tileId: tile.id }));
                    const img = document.createElement("img");
                    img.src = "data:image/svg+xml;charset=utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='1' height='1'></svg>");
                    e.dataTransfer.setDragImage(img, 0, 0);
                });
                el.addEventListener("dragend", () => el.classList.remove("dragging"));
            }

            return el;
        }

        /* ---------------------------
        Board & dock
        ----------------------------*/
        const trayEl = document.getElementById("tray");
        const slots = {
            tl: document.querySelector(".slot.tl"),
            tr: document.querySelector(".slot.tr"),
            bl: document.querySelector(".slot.bl"),
            br: document.querySelector(".slot.br")
        };
        function clearBoardAndTray() {
            trayEl.innerHTML = "";
            for (const s of Object.values(slots)) s.innerHTML = "";
            state.placed = { tl: null, tr: null, bl: null, br: null };
        }

        /* Drop handlers ‚Äî prevent dropping onto locked tiles; keep state.placed consistent */
        for (const [slotName, slotEl] of Object.entries(slots)) {
            slotEl.addEventListener("dragover", (e) => { e.preventDefault(); slotEl.classList.add("highlight"); });
            slotEl.addEventListener("dragleave", () => slotEl.classList.remove("highlight"));
            slotEl.addEventListener("drop", (e) => {
                e.preventDefault();
                slotEl.classList.remove("highlight");

                const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
                const tileEl = document.querySelector(`.tile[data-id="${data.tileId}"]`);
                if (!tileEl) return;

                const existing = slotEl.querySelector(".tile");

                // Don't allow dropping onto a slot that already has a locked tile
                if (existing && existing.classList.contains("locked")) return;

                // If slot contains a (non-locked) tile, move it back to tray
                if (existing) trayEl.appendChild(existing);

                // Can't drop a locked tile anywhere else
                if (tileEl.classList.contains("locked")) return;

                // Place tile and sync state
                slotEl.appendChild(tileEl);
                state.placed[slotName] = {
                    tileId: tileEl.dataset.id,
                    rotation: parseInt(tileEl.dataset.rotation, 10)
                };

                updateScoreButtonState();
            });
        }

        /* Enable dropping tiles back into the dock (drag off board) */
        trayEl.addEventListener("dragover", (e) => { e.preventDefault(); });
        trayEl.addEventListener("drop", (e) => {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData("text/plain") || "{}");
            if (!data.tileId) return;
            const tileEl = document.querySelector(`.tile[data-id="${data.tileId}"]`);
            if (!tileEl || tileEl.classList.contains("locked")) return; // don't move locked tiles

            // If the tile was in a slot, clear that slot's state
            const parentSlotName = tileEl.parentElement?.dataset?.slot;
            if (parentSlotName) state.placed[parentSlotName] = null;

            trayEl.appendChild(tileEl);
            updateScoreButtonState();
        });

        /* ---------------------------
        Outside-edge clues (hide pair words until end)
        ----------------------------*/
        const clueRefs = {
            top: document.querySelector("#clueTop"),
            right: document.querySelector("#clueRight"),
            bottom: document.querySelector("#clueBottom"),
            left: document.querySelector("#clueLeft")
        };
        function setClueHintsFromSolution() {
            const getTile = id => state.tiles.find(t => t.id === id);
            const wordsFor = (slotName, edgeIdx) => {
                const sol = state.solution[slotName];
                return rotWords(getTile(sol.tileId).words, sol.rotation)[edgeIdx];
            };
            const topPair = wordsFor("tl", 0) + " ‚Ä¢ " + wordsFor("tr", 0);
            const rightPair = wordsFor("tr", 1) + " ‚Ä¢ " + wordsFor("br", 1);
            const bottomPair = wordsFor("bl", 2) + " ‚Ä¢ " + wordsFor("br", 2);
            const leftPair = wordsFor("tl", 3) + " ‚Ä¢ " + wordsFor("bl", 3);

            clueRefs.top.querySelector(".hint").textContent = `Words: ${topPair}`;
            clueRefs.right.querySelector(".hint").textContent = `Words: ${rightPair}`;
            clueRefs.bottom.querySelector(".hint").textContent = `Words: ${bottomPair}`;
            clueRefs.left.querySelector(".hint").textContent = `Words: ${leftPair}`;

            // Ensure they are hidden initially
            setHintsVisible(false);
        }
        function setHintsVisible(visible) {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const hintEl = clueRefs[dir].querySelector(".hint");
                hintEl.style.display = visible ? "block" : "none";
            }
        }
        function showClueLabels() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir], input = box.querySelector("input"), text = box.querySelector(".text");
                const val = (input.value || "").trim();
                input.style.display = "none";
                text.style.display = "block";
                text.textContent = val.length ? val : `(${dir} clue)`;
            }
        }
        function showClueInputs() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir];
                box.querySelector("input").style.display = "block";
                box.querySelector(".text").style.display = "none";
            }
        }

        /* ---------------------------
        NEW: clear clue inputs & labels
        ----------------------------*/
        function clearClueBoxes() {
            for (const dir of ["top", "right", "bottom", "left"]) {
                const box = clueRefs[dir];
                const input = box.querySelector("input");
                const text = box.querySelector(".text");
                const hint = box.querySelector(".hint");
                input.value = "";
                text.textContent = "";
                hint.textContent = "";
                input.style.display = "block";
                text.style.display = "none";
            }
            setHintsVisible(false);
        }

        /* ---------------------------
        Gating buttons
        ----------------------------*/
        const doneBtn = document.getElementById("doneBtn");
        const scoreBtn = document.getElementById("scoreBtn");

        function updateDoneButtonState() {
            const topVal = clueRefs.top.querySelector("input").value.trim();
            const rightVal = clueRefs.right.querySelector("input").value.trim();
            const bottomVal = clueRefs.bottom.querySelector("input").value.trim();
            const leftVal = clueRefs.left.querySelector("input").value.trim();
            const allFilled = topVal.length && rightVal.length && bottomVal.length && leftVal.length;
            doneBtn.disabled = !(state.phase === "clue" && allFilled);
        }
        ["top", "right", "bottom", "left"].forEach(dir => {
            clueRefs[dir].querySelector("input").addEventListener("input", updateDoneButtonState);
        });

        function updateScoreButtonState() {
            if (state.phase !== "guess") { scoreBtn.disabled = true; return; }
            const allSlotsHaveTiles =
                !!slots.tl.querySelector(".tile") &&
                !!slots.tr.querySelector(".tile") &&
                !!slots.bl.querySelector(".tile") &&
                !!slots.br.querySelector(".tile");
            scoreBtn.disabled = !allSlotsHaveTiles;
        }

        /* ---------------------------
        Round generation
        ----------------------------*/
        function newRound() {
            // Clear clues from previous round
            clearClueBoxes();

            // Build 5 tiles: first 4 are the solution, 5th is decoy
            clearBoardAndTray();
            nextTileId = 1;
            state.tiles = [];

            // Shuffle word bank, take chunks of 4 words per tile
            const bank = shuffle(WORDS.slice(), Math.random);

            let idx = 0;
            function take4() {
                const chunk = bank.slice(idx, idx + 4);
                idx += 4;
                return chunk.length === 4 ? chunk : shuffle(WORDS.slice(), Math.random).slice(0, 4);
            }

            const solutionTiles = [];
            for (let i = 0; i < 4; i++) {
                const tile = makeTile(take4());
                state.tiles.push(tile);
                solutionTiles.push(tile);
            }
            const decoy = makeTile(take4());
            state.tiles.push(decoy);

            // Random solution mapping for 4 slots (TL, TR, BL, BR) and rotations
            const slotNames = ["tl", "tr", "bl", "br"];
            const tilesShuffled = shuffle(solutionTiles.slice(), Math.random);
            const rotations = shuffle([0, 1, 2, 3], Math.random);
            state.solution = { tl: null, tr: null, bl: null, br: null };
            for (let i = 0; i < 4; i++) {
                state.solution[slotNames[i]] = { tileId: tilesShuffled[i].id, rotation: rotations[i] };
            }

            // Render tiles fixed (clue phase), dim inner edges
            for (const slotName of slotNames) {
                const sol = state.solution[slotName];
                const tile = solutionTiles.find(t => t.id === sol.tileId);
                const el = createTileElement(tile, sol.rotation, { draggable: false, rotatable: false, dimInner: true, slotName });
                slots[slotName].appendChild(el);
            }

            // Prepare outside-edge clues (pair words hidden)
            setClueHintsFromSolution();
            showClueInputs(); // ensure inputs visible
            setHintsVisible(false); // keep pair words hidden

            state.roundScore = 0;
            document.getElementById("roundScore").textContent = "0";
            document.getElementById("scoreHint").textContent =
                "Perfect on first attempt awards 6 points (1 per card + 2 bonus). Otherwise, second attempt scores 1 per correct card.";
            setPhase("clue");
            setAttempt(1);

            // Gate the Done button until all 4 clues are entered
            updateDoneButtonState();

            scoreBtn.disabled = true;
            log("Clue Phase: enter the 4 outside-edge clues. ‚ÄúDone‚Äù enables when all four are filled.");
        }

        function startGuessPhase() {
            if (state.phase !== "clue") return;

            // Switch clues to labels (still keep pair words hidden)
            showClueLabels();
            setHintsVisible(false);

            // Remove tiles from board; build dock with the original 4 + 1 decoy
            document.querySelectorAll(".tile").forEach(el => el.remove());
            trayEl.innerHTML = "";
            const tilesShuffled = shuffle(state.tiles.slice(), Math.random); // includes decoy
            for (const tile of tilesShuffled) {
                const randomRot = Math.floor(Math.random() * 4);
                const el = createTileElement(tile, randomRot, { draggable: true, rotatable: true });
                trayEl.appendChild(el);
            }

            setPhase("guess");
            setAttempt(1);
            doneBtn.disabled = true; // Done only for clue phase
            updateScoreButtonState();
            log("Resolution Phase: Drag cards to TL/TR/BL/BR. Click a card to rotate 90¬∞. Drag off the board to return to the dock. Then click Score.");
        }

        /* ---------------------------
        Scoring ‚Äî uses live DOM state and gated Score
        ----------------------------*/
        function scoreGuess() {
            if (state.phase !== "guess") return;
            // Prevent scoring unless all tiles are placed
            updateScoreButtonState();
            if (scoreBtn.disabled) return;

            const slotNames = ["tl", "tr", "bl", "br"];
            let lockedCount = 0;

            for (const slotName of slotNames) {
                const sol = state.solution[slotName];
                const slotEl = slots[slotName];
                const tileEl = slotEl.querySelector(".tile");
                if (!tileEl) continue;

                const placedId = tileEl.dataset.id;
                const placedRot = parseInt(tileEl.dataset.rotation, 10);

                const isCorrect = sol.tileId === placedId && sol.rotation === placedRot;

                if (isCorrect) {
                    // Lock if not already
                    if (!tileEl.classList.contains("locked")) {
                        tileEl.classList.add("locked");
                        tileEl.draggable = false;
                    }
                    lockedCount++;
                } else {
                    // Only eject if it's not locked (never eject a locked tile)
                    if (!tileEl.classList.contains("locked")) {
                        trayEl.appendChild(tileEl);
                        state.placed[slotName] = null;
                    }
                }
            }

            if (state.attempt === 1) {
                if (lockedCount === 4) {
                    state.roundScore = 6;
                    document.getElementById("roundScore").textContent = state.roundScore;
                    setPhase("complete");
                    scoreBtn.disabled = true;
                    // Reveal pair words now that the round is complete
                    setHintsVisible(true);
                    log("üéâ Perfect! All four cards correct on the first try. +6 points.");
                } else {
                    setAttempt(2);
                    document.getElementById("scoreHint").textContent =
                        "Second attempt: place remaining cards. You‚Äôll score 1 point per correct card.";
                    log(`Locked ${lockedCount} correct card(s). Incorrect cards returned to the dock. Make your second attempt.`);
                    // Require all slots filled again before scoring the second attempt
                    updateScoreButtonState();
                }
            } else if (state.attempt === 2) {
                // Count locked correct cards (some may have been locked in first attempt)
                const lockedFinal = ["tl", "tr", "bl", "br"].filter(s => slots[s].querySelector(".tile.locked")).length;
                state.roundScore = lockedFinal; // 0‚Äì4
                document.getElementById("roundScore").textContent = state.roundScore;
                setPhase("complete");
                scoreBtn.disabled = true;
                // Reveal pair words now that the round is complete
                setHintsVisible(true);
                log(`Round complete. You scored ${lockedFinal} point(s) on the second attempt.`);
            }
        }

        /* ---------------------------
        New Round button ‚Äî gated with confirmation during active round
        ----------------------------*/
        document.getElementById("newRoundBtn").addEventListener("click", () => {
            // Show confirmation only if the round is active (clue or guess)
            if (state.phase === "clue" || state.phase === "guess") {
                const ok = window.confirm("Start a new round? This will discard the current round.");
                if (!ok) return;
            }
            // If idle or complete, no prompt
            newRound();
        });

        /* ---------------------------
        Wire up remaining controls
        ----------------------------*/
        document.getElementById("doneBtn").addEventListener("click", startGuessPhase);
        document.getElementById("scoreBtn").addEventListener("click", scoreGuess);

        /* Init */
        (function init() {
            setPhase("idle");
            setAttempt(0);
            document.getElementById("roundScore").textContent = "0";
            document.getElementById("scoreHint").textContent = "";
            log("Click ‚ÄúNew Round‚Äù to begin.");
        })();
        // Collapsible scoring reference
        const scoreRefToggle = document.getElementById("scoreRefToggle");
        const scoreRefBody = document.getElementById("scoreRefBody");

        scoreRefToggle?.addEventListener("click", () => {
            const isOpen = !scoreRefBody.hasAttribute("hidden");
            scoreRefBody.toggleAttribute("hidden", isOpen);
            scoreRefToggle.setAttribute("aria-expanded", String(!isOpen));
            scoreRefToggle.textContent = `Scoring Reference ${isOpen ? "‚ñæ" : "‚ñ¥"}`;
        });

    </script>

</body>

</html>